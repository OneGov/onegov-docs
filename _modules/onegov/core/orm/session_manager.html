
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>onegov.core.orm.session_manager &#8212; OneGov Docs 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for onegov.core.orm.session_manager</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">zope.sqlalchemy</span>

<span class="kn">from</span> <span class="nn">blinker</span> <span class="k">import</span> <span class="n">Signal</span>
<span class="kn">from</span> <span class="nn">onegov.core.cache</span> <span class="k">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">onegov.core.custom</span> <span class="k">import</span> <span class="n">json</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">text</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">scoped_session</span><span class="p">,</span> <span class="n">sessionmaker</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.pool</span> <span class="k">import</span> <span class="n">QueuePool</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm.query</span> <span class="k">import</span> <span class="n">Query</span>
<span class="kn">from</span> <span class="nn">sqlalchemy_utils.aggregates</span> <span class="k">import</span> <span class="n">manager</span> <span class="k">as</span> <span class="n">aggregates_manager</span>


<span class="c1"># Limits the lifteime of sessions for n seconds. Postgres will automatically</span>
<span class="c1"># reap connections which are unused for longer and we will automatically</span>
<span class="c1"># recreate connections which are activated after that.</span>
<span class="c1">#</span>
<span class="c1"># This boils down to connections being recycled once an hour. As each</span>
<span class="c1"># connection is handled by a separate process by Postgres - a process which</span>
<span class="c1"># may grow quite large - this alleviates memory fragmentation/high water mark</span>
<span class="c1"># issues that we&#39;ve been seeing on some servers.</span>
<span class="n">CONNECTION_LIFETIME</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span>


<span class="k">class</span> <span class="nc">ForceFetchQueryClass</span><span class="p">(</span><span class="n">Query</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Alters the buitlin query class, ensuring that the delete query always</span>
<span class="sd">    fetches the data first, which is important for the bulk delete events</span>
<span class="sd">    to get the actual objects affected by the change.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">&#39;fetch&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="query_schemas"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.query_schemas">[docs]</a><span class="k">def</span> <span class="nf">query_schemas</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Yields all schemas or the ones with the given namespace. &quot;&quot;&quot;</span>

    <span class="n">query</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        SELECT schema_name</span>
<span class="s2">        FROM information_schema.schemata</span>
<span class="s2">        ORDER BY schema_name</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="n">namespace</span> <span class="ow">and</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{namespace}</span><span class="s1">-&#39;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="p">)</span> <span class="ow">in</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix</span> <span class="ow">or</span> <span class="n">schema</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">schema</span></div>


<div class="viewcode-block" id="SessionManager"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager">[docs]</a><span class="k">class</span> <span class="nc">SessionManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Holds sessions and creates schemas before binding sessions to schemas.</span>

<span class="sd">    Threadsafe in theory, but not tested or well thought out. No global state</span>
<span class="sd">    though, so two different session managers will manage different</span>
<span class="sd">    sessions/schemas.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># describes the accepted characters in a schema name</span>
    <span class="n">_valid_schema_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^[a-z0-9_-]+$&#39;</span><span class="p">)</span>

    <span class="c1"># describes the prefixes with which a schema may not begin</span>
    <span class="n">_invalid_prefixes</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^([0-9]|pg_)+&#39;</span><span class="p">)</span>

    <span class="c1"># holds schemas that may never be used:</span>
    <span class="c1"># - information_schema is a sql standard schema that&#39;s for internal use</span>
    <span class="c1"># - public is the default schema name which should not be used for security</span>
    <span class="c1">#   reasons. Someone could figure out a way to set the search_path to</span>
    <span class="c1">#   default and to add an application that has the right to change the</span>
    <span class="c1">#   public schema.</span>
    <span class="n">_reserved_schemas</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;information_schema&#39;</span><span class="p">,</span> <span class="s1">&#39;public&#39;</span><span class="p">,</span> <span class="s1">&#39;extensions&#39;</span><span class="p">}</span>

    <span class="c1"># holds thread local data</span>
    <span class="n">_thread_bound</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dsn</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
                 <span class="n">engine_config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">session_config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool_config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Configures the data source name/dsn/database url and sets up the</span>
<span class="sd">        connection to the database.</span>

<span class="sd">        :dsn:</span>
<span class="sd">            Database connection string including user, password, host, port</span>
<span class="sd">            and database name.</span>

<span class="sd">            See: `&lt;http://docs.sqlalchemy.org/en/latest/core/engines.html\</span>
<span class="sd">            #database-urls&gt;`_</span>

<span class="sd">        :base:</span>
<span class="sd">            Declarative base used to define the SQLAlchemy database models.</span>

<span class="sd">            Extra bases may be added to the session manager after __init__::</span>

<span class="sd">                mgr.bases.append(MyBase)</span>

<span class="sd">            The tables in these additional schemas are created on the schema</span>
<span class="sd">            alongside the primary base.</span>

<span class="sd">        :engine_config:</span>
<span class="sd">            Additional configuration passed to SQLAlchemy&#39;s `create_engine`.</span>

<span class="sd">            See: `&lt;http://docs.sqlalchemy.org/en/latest/core/engines.html\</span>
<span class="sd">            #sqlalchemy.create_engine&gt;`</span>

<span class="sd">        :session_config:</span>
<span class="sd">            Additional configuration passed to SQLAlchemy&#39;s sessionmaker.</span>

<span class="sd">            See: `&lt;http://docs.sqlalchemy.org/en/latest/orm/session_api.html\</span>
<span class="sd">            #sqlalchemy.orm.session.sessionmaker&gt;`</span>

<span class="sd">        :pool_config:</span>
<span class="sd">            Custom pool configuration to be used in lieue of the default pool.</span>
<span class="sd">            Only use under special circumstances.</span>

<span class="sd">        Note, to connect to another database you need to create a new</span>
<span class="sd">        SessionManager instance.</span>

<span class="sd">        **Postgres Extensions**</span>

<span class="sd">        The session manager supports the setup of postgres extensions.</span>
<span class="sd">        Currently those extensions are hard-coded and they are all added to the</span>
<span class="sd">        extensions schema. The extensions schema is then added to the search</span>
<span class="sd">        path of each query.</span>

<span class="sd">        Since extensions can only be created by superusers, this is something</span>
<span class="sd">        you might want to do in a separate step in deployment. We don&#39;t advise</span>
<span class="sd">        you to use a superuser connection for your onegov cloud deployment.</span>

<span class="sd">        You may therefore use the list of the required extensions below and</span>
<span class="sd">        create a schema &#39;extensions&#39; with those extensions inside.</span>

<span class="sd">        **Signals**</span>

<span class="sd">        The session manager supports the following signals:</span>

<span class="sd">        ``self.on_insert``</span>

<span class="sd">        Called with the schema and each object when an insert happens.</span>

<span class="sd">        ``self.on_update``</span>

<span class="sd">        Called with the schema and each object when a change happens.</span>

<span class="sd">        ``self.on_delete``</span>

<span class="sd">        Called with the scheam and each object when a change happens. Note that</span>
<span class="sd">        because those objects basically do not exist anymore, only the</span>
<span class="sd">        primary keys of those objects contain actual values!</span>

<span class="sd">        Signals abstracts SQLAlchemy ORM events. Since those handle events</span>
<span class="sd">        of the Session, only things happening on sessions provided by this</span>
<span class="sd">        sessionmanager are caught. Raw SQL queries, other sessions and other</span>
<span class="sd">        outside changes to the database are not caught!</span>

<span class="sd">        The signals are implemented using blinker:</span>
<span class="sd">        `&lt;https://pythonhosted.org/blinker/&gt;`_</span>

<span class="sd">        Note that signal handler functions are by default attached as weakrefs,</span>
<span class="sd">        that means if you create your signal handling function inside another</span>
<span class="sd">        function, the signal will stop working once the outer function</span>
<span class="sd">        completes.</span>

<span class="sd">        To avoid this behavior use ``connect_via``. See examples below:</span>

<span class="sd">        Examples::</span>

<span class="sd">            mgr = SessionManager(dsn)</span>

<span class="sd">            # connect to the insert signal, disconnecting automatically once</span>
<span class="sd">            # the handler function is garbage collected</span>
<span class="sd">            @mgr.on_insert.connect</span>
<span class="sd">            def on_insert(schema, obj):</span>
<span class="sd">                print(&quot;Inserted {} @ {}&quot;.format(obj, schema))</span>

<span class="sd">            # connect to the update signal, limited to a specific schema, also</span>
<span class="sd">            # disconnecting automatically once the handler function falls out</span>
<span class="sd">            # of scope</span>
<span class="sd">            @mgr.on_update.connect_via(&#39;my-schema&#39;)</span>
<span class="sd">            def on_update(schema, obj):</span>
<span class="sd">                print(&quot;Updated {} @ {}&quot;.format(obj, schema))</span>

<span class="sd">            # connect to the delete signal for all schemas -&gt; here, the</span>
<span class="sd">            # handler is strongly referenced and may be used in a closure</span>
<span class="sd">            from blinker import ANY</span>
<span class="sd">            @mgr.on_delete.connect_via(ANY, weak=False)</span>
<span class="sd">            def on_delete(schema, obj):</span>
<span class="sd">                print(&quot;Deleted {} @ {}&quot;.format(obj, schema))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s1">&#39;postgres&#39;</span> <span class="ow">in</span> <span class="n">dsn</span><span class="p">,</span> <span class="s2">&quot;Onegov only supports Postgres!&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>

        <span class="n">engine_config</span> <span class="o">=</span> <span class="n">engine_config</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">session_config</span> <span class="o">=</span> <span class="n">session_config</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">pool_config</span> <span class="o">=</span> <span class="n">pool_config</span> <span class="ow">or</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dsn</span> <span class="o">=</span> <span class="n">dsn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created_schemas</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_schema</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_insert</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_update</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_delete</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>

        <span class="c1"># onegov.core creates extensions that it requires in a separate schema</span>
        <span class="c1"># in the future, this might become something we can configure through</span>
        <span class="c1"># the setuptools entry_points -&gt; modules could advertise what they need</span>
        <span class="c1"># and the core would install the extensions the modules require</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">required_extensions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;btree_gist&#39;</span><span class="p">,</span> <span class="s1">&#39;hstore&#39;</span><span class="p">,</span> <span class="s1">&#39;unaccent&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created_extensions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># override the isolation level in any case, we cannot allow another</span>
        <span class="n">engine_config</span><span class="p">[</span><span class="s1">&#39;isolation_level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SERIALIZABLE&#39;</span>

        <span class="c1"># provide our custom serializer to the engine</span>
        <span class="k">assert</span> <span class="s1">&#39;json_serializer&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">engine_config</span>
        <span class="k">assert</span> <span class="s1">&#39;json_deserializer&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">engine_config</span>

        <span class="n">engine_config</span><span class="p">[</span><span class="s1">&#39;json_serializer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span>
        <span class="n">engine_config</span><span class="p">[</span><span class="s1">&#39;json_deserializer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span>

        <span class="k">if</span> <span class="n">pool_config</span><span class="p">:</span>
            <span class="n">engine_config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pool_config</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the default pool config should work for all onegov applications</span>
            <span class="c1">#</span>
            <span class="c1"># currently most applications use one single connection that is</span>
            <span class="c1"># reused between requests as well as one extra connection for each</span>
            <span class="c1"># instance (cronjob thread with session-based lock)</span>
            <span class="n">engine_config</span><span class="p">[</span><span class="s1">&#39;poolclass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QueuePool</span>

            <span class="c1"># connections which are kept open when returned to the pool</span>
            <span class="n">engine_config</span><span class="p">[</span><span class="s1">&#39;pool_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">engine_config</span><span class="p">[</span><span class="s1">&#39;pool_recycle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONNECTION_LIFETIME</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># connections which are closed when returned (unlimited)</span>
            <span class="n">engine_config</span><span class="p">[</span><span class="s1">&#39;max_overflow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dsn</span><span class="p">,</span> <span class="o">**</span><span class="n">engine_config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_engine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session_factory</span> <span class="o">=</span> <span class="n">scoped_session</span><span class="p">(</span>
            <span class="n">sessionmaker</span><span class="p">(</span>
                <span class="n">bind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span>
                <span class="n">query_cls</span><span class="o">=</span><span class="n">ForceFetchQueryClass</span><span class="p">,</span>
                <span class="o">**</span><span class="n">session_config</span>
            <span class="p">),</span>
            <span class="n">scopefunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scopefunc</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_session</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_factory</span><span class="p">)</span>

<div class="viewcode-block" id="SessionManager.register_engine"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.register_engine">[docs]</a>    <span class="k">def</span> <span class="nf">register_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Takes the given engine and registers it with the schema</span>
<span class="sd">        switching mechanism. Maybe used to register external engines with</span>
<span class="sd">        the session manager.</span>

<span class="sd">        If used like this, make sure to call :meth:`bind_session` before using</span>
<span class="sd">        the session provided by the external engine.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;before_cursor_execute&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">activate_schema</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Share the &#39;info&#39; dictionary of Session with Connection</span>
<span class="sd">            objects.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># execution options have priority!</span>
            <span class="k">if</span> <span class="s1">&#39;schema&#39;</span> <span class="ow">in</span> <span class="n">connection</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">:</span>
                <span class="n">schema</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">[</span><span class="s1">&#39;schema&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;session&#39;</span> <span class="ow">in</span> <span class="n">connection</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                    <span class="n">schema</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;schema&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">schema</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SET search_path TO </span><span class="si">%s</span><span class="s2">, extensions&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="p">))</span>

        <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;before_cursor_execute&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">limit_session_lifetime</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Kills idle sessions after a while, freeing up memory. &quot;&quot;&quot;</span>

            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
                <span class="s2">&quot;SET SESSION idle_in_transaction_session_timeout = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{CONNECTION_LIFETIME}</span><span class="s1">s&#39;</span><span class="p">,</span> <span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="SessionManager.register_session"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.register_session">[docs]</a>    <span class="k">def</span> <span class="nf">register_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Takes the given session and registers it with zope.sqlalchemy and</span>
<span class="sd">        various orm events.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">signals</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_insert</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">session</span><span class="p">:</span> <span class="n">session</span><span class="o">.</span><span class="n">new</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_update</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">session</span><span class="p">:</span> <span class="n">session</span><span class="o">.</span><span class="n">dirty</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_delete</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">session</span><span class="p">:</span> <span class="n">session</span><span class="o">.</span><span class="n">deleted</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># SQLAlchemy-Utils&#39; aggregates decorator doesn&#39;t work correctly</span>
        <span class="c1"># with our sessions - we need to setup the appropriate event handler</span>
        <span class="c1"># manually. There&#39;s a test that makes sure that this is not done</span>
        <span class="c1"># twice. The cause of this has to be investigated still.</span>
        <span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">session</span><span class="p">,</span>
            <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;after_flush&#39;</span><span class="p">,</span>
            <span class="n">fn</span><span class="o">=</span><span class="n">aggregates_manager</span><span class="o">.</span><span class="n">construct_aggregate_queries</span>
        <span class="p">)</span>

        <span class="c1"># This check we need in any case, since aggregates don&#39;t work with</span>
        <span class="c1"># bulk udpdates/deletes, which is something we make sure can&#39;t</span>
        <span class="c1"># happen by accident (it&#39;ll lead to hard to debug errors)</span>
        <span class="n">cache_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aggregates_manager</span><span class="o">.</span><span class="n">generator_registry</span><span class="p">),</span> <span class="mi">32</span><span class="p">)</span>

        <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">cache_size</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">prevent_bulk_changes_on_aggregate_modules</span><span class="p">(</span><span class="n">module_class</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">registered</span> <span class="ow">in</span> <span class="n">aggregates_manager</span><span class="o">.</span><span class="n">generator_registry</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">module_class</span><span class="p">,</span> <span class="n">registered</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    Bulk queries run on models that use sqlalchemy-utils</span>
<span class="s2">                    aggregates won&#39;t lead to a proper update. It&#39;s impossible</span>
<span class="s2">                    to have both aggregates and bulk updates/deletes.</span>
<span class="s2">                &quot;&quot;&quot;</span>

        <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;after_flush&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">on_after_flush</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">signal</span><span class="p">,</span> <span class="n">get_objects</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">receivers</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">get_objects</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
                        <span class="n">signal</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_schema</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">)</span>

        <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;after_bulk_update&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">on_after_bulk_update</span><span class="p">(</span><span class="n">update_context</span><span class="p">):</span>
            <span class="n">prevent_bulk_changes_on_aggregate_modules</span><span class="p">(</span>
                <span class="n">update_context</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_update</span><span class="o">.</span><span class="n">receivers</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">update_context</span><span class="p">,</span> <span class="s1">&#39;matched_objects&#39;</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    Bulk queries which use synchronize_session=False or</span>
<span class="s2">                    synchronize_session=&#39;fetch&#39; cannot be supported because</span>
<span class="s2">                    it is unclear what rows were affected. Manually update</span>
<span class="s2">                    values instead (even though it&#39;s way slower). There&#39;s no</span>
<span class="s2">                    better solution at the moment.</span>
<span class="s2">                &quot;&quot;&quot;</span>

                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">update_context</span><span class="o">.</span><span class="n">matched_objects</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">on_update</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_schema</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">)</span>

        <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;after_bulk_delete&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">on_after_bulk_delete</span><span class="p">(</span><span class="n">delete_context</span><span class="p">):</span>
            <span class="n">prevent_bulk_changes_on_aggregate_modules</span><span class="p">(</span>
                <span class="n">delete_context</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_delete</span><span class="o">.</span><span class="n">receivers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">delete_context</span><span class="o">.</span><span class="n">matched_rows</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">delete_context</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span>
                        <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">delete_context</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
                    <span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">on_delete</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_schema</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">zope</span><span class="o">.</span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">session</span><span class="p">)</span></div>

<div class="viewcode-block" id="SessionManager.activate"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.activate">[docs]</a>    <span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sets the currently active session_manager - this is basically a</span>
<span class="sd">        global variable we require because we hook into the orm/query events</span>
<span class="sd">        where we don&#39;t know yet which session is going to be used and therefore</span>
<span class="sd">        cannot be sure about the used session manager either</span>

<span class="sd">        For example, the Document model below needs access to the current</span>
<span class="sd">        session to get the current locale, but since it is instantiated without</span>
<span class="sd">        any session information, this can&#39;t be known without a global variable:</span>

<span class="sd">            document = Document(localized_title=&quot;Das Dokument&quot;)</span>

<span class="sd">        We can only work around that with a global variable:</span>

<span class="sd">            session_manager.activate()</span>
<span class="sd">            document = Document(localized_title=&quot;Das Dokument&quot;)</span>

<span class="sd">        As a result session managers need to be activated, or they can&#39;t be</span>
<span class="sd">        used (at least for translated columns). To do so in tests, use:</span>

<span class="sd">            session_manager.activate()</span>

<span class="sd">        To ease the use of testing the last session_manager is however also</span>
<span class="sd">        automatically activated when the schema is set, which covers most</span>
<span class="sd">        use-cases outside of testing</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">set_active</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SessionManager.deactivate"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.deactivate">[docs]</a>    <span class="k">def</span> <span class="nf">deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sets the currently active session manager to None, if it is equal</span>
<span class="sd">        to self.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">get_active</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">active</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">active</span><span class="o">.</span><span class="fm">__repr__</span><span class="o">.</span><span class="vm">__self__</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_active</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_active</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">session_manager</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">session_manager</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_thread_bound</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">session_manager</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_thread_bound</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_active</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_thread_bound</span><span class="o">.</span><span class="n">_active</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ReferenceError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="SessionManager.set_locale"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.set_locale">[docs]</a>    <span class="k">def</span> <span class="nf">set_locale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_locale</span><span class="p">,</span> <span class="n">current_locale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sets the default locale and the current locale so it may be</span>
<span class="sd">        shared with the translated ORM columns.</span>

<span class="sd">        Note that the locales may be NONE. It is up to the consumer of these</span>
<span class="sd">        settings to assert their existence.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_locale</span> <span class="o">=</span> <span class="n">default_locale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_locale</span> <span class="o">=</span> <span class="n">current_locale</span></div>

    <span class="k">def</span> <span class="nf">_scopefunc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the scope of the scoped_session used to create new</span>
<span class="sd">        sessions. Relies on self.current_schema being set before the</span>
<span class="sd">        session is created.</span>

<span class="sd">        This function is as internal as they come and it exists only because</span>
<span class="sd">        we otherwise would have to create different session factories for each</span>
<span class="sd">        schema.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_schema</span><span class="p">)</span>

<div class="viewcode-block" id="SessionManager.dispose"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.dispose">[docs]</a>    <span class="k">def</span> <span class="nf">dispose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Closes the connection to the server and cleans up. This only needed</span>
<span class="sd">        for testing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">raw_connection</span><span class="p">()</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span></div>

<div class="viewcode-block" id="SessionManager.is_valid_schema"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.is_valid_schema">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns True if the given schema looks valid enough to be created</span>
<span class="sd">        on the database with no danger of SQL injection or other unwanted</span>
<span class="sd">        sideeffects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">schema</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">schema</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_schemas</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_prefixes</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># only one consecutive &#39;-&#39; is allowed (-- constitues a comment)</span>
        <span class="k">if</span> <span class="s1">&#39;--&#39;</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_schema_name</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span> <span class="ow">and</span> <span class="kc">True</span> <span class="ow">or</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="SessionManager.set_current_schema"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.set_current_schema">[docs]</a>    <span class="k">def</span> <span class="nf">set_current_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sets the current schema in use. The current schema is then used</span>
<span class="sd">        to bind the session to a schema. Note that this can&#39;t be done</span>
<span class="sd">        in a functional way. We need the current schema to generate a new</span>
<span class="sd">        scope.</span>

<span class="sd">        I would very much prefer to bind this to the session but this is not</span>
<span class="sd">        at all straight-forward with SQLAlchemy.</span>

<span class="sd">        I tried a solution like `this one &lt;https://bitbucket.org/zzzeek/\</span>
<span class="sd">        sqlalchemy/wiki/UsageRecipes/SessionModifiedSQL&gt;`_, but it&#39;s not good</span>
<span class="sd">        enough, because it still relies on some kind of global stage, even if</span>
<span class="sd">        it&#39;s set locally.</span>

<span class="sd">        Ideally a value could be bound to the session and an event would</span>
<span class="sd">        trigger every time the connection is used with that session. We</span>
<span class="sd">        could then set the schema on the connection every time that happens.</span>

<span class="sd">        For now, the global option is okay though, because in practice we</span>
<span class="sd">        only set the schema once per request and we don&#39;t do threading</span>
<span class="sd">        anyway.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_schema_exists</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span></div>

<div class="viewcode-block" id="SessionManager.create_schema"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.create_schema">[docs]</a>    <span class="k">def</span> <span class="nf">create_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates the given schema. If said schema exists, expect this</span>
<span class="sd">        method to throw an error. If you use :meth:`set_current_schema`,</span>
<span class="sd">        this is invoked automatically if needed. So you usually shouldn&#39;t</span>
<span class="sd">        have to care about this function.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

        <span class="c1"># psycopg2 doesn&#39;t know how to correctly build a CREATE</span>
        <span class="c1"># SCHEMA statement, so we need to do it manually.</span>
        <span class="c1"># self.is_valid_schema should&#39;ve checked that no sql</span>
        <span class="c1"># injections are possible.</span>
        <span class="c1">#</span>
        <span class="c1"># this is the *only* place where this happens - if anyone</span>
        <span class="c1"># knows how to do this using sqlalchemy/psycopg2, come forward!</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;CREATE SCHEMA &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;COMMIT&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SessionManager.create_schema_if_not_exists"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.create_schema_if_not_exists">[docs]</a>    <span class="k">def</span> <span class="nf">create_schema_if_not_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates the given schema if it doesn&#39;t exist yet. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_schema_found_on_database</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">validate</span><span class="p">)</span></div>

<div class="viewcode-block" id="SessionManager.bind_session"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.bind_session">[docs]</a>    <span class="k">def</span> <span class="nf">bind_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Bind the session to the current schema. &quot;&quot;&quot;</span>
        <span class="n">session</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;schema&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_schema</span>
        <span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">session</span></div>

<div class="viewcode-block" id="SessionManager.session"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.session">[docs]</a>    <span class="k">def</span> <span class="nf">session</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a new session or an existing session. Sessions with</span>
<span class="sd">        different schemas are kept independent, though they might reuse</span>
<span class="sd">        each others connections.</span>

<span class="sd">        This means that a session retrieved thusly::</span>

<span class="sd">            mgr = SessionManager(&#39;postgres://...&#39;)</span>
<span class="sd">            mgr.set_current_schema(&#39;foo&#39;)</span>
<span class="sd">            session = mgr.session()</span>

<span class="sd">        Will not see objects attached to this session::</span>

<span class="sd">            mgr.set_current_schema(&#39;bar&#39;)</span>
<span class="sd">            session = mgr.session()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind_session</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_factory</span><span class="p">())</span></div>

<div class="viewcode-block" id="SessionManager.list_schemas"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.list_schemas">[docs]</a>    <span class="k">def</span> <span class="nf">list_schemas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a tuple containing *all* schemas defined in the current</span>
<span class="sd">        database.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">query_schemas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span> <span class="n">namespace</span><span class="p">))</span></div>

<div class="viewcode-block" id="SessionManager.is_schema_found_on_database"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.is_schema_found_on_database">[docs]</a>    <span class="k">def</span> <span class="nf">is_schema_found_on_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns True if the given schema exists on the database. &quot;&quot;&quot;</span>

        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">text</span><span class="p">(</span>
            <span class="s2">&quot;SELECT EXISTS(SELECT 1 FROM information_schema.schemata &quot;</span>
            <span class="s2">&quot;WHERE schema_name = :schema)&quot;</span>
        <span class="p">),</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="SessionManager.create_required_extensions"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.create_required_extensions">[docs]</a>    <span class="k">def</span> <span class="nf">create_required_extensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates the required extensions once per lifetime of the manager.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">required_extensions</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">created_extensions</span><span class="p">:</span>

            <span class="c1"># extensions are a all added to a shared schema (a reserved schema)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_schema_if_not_exists</span><span class="p">(</span><span class="s1">&#39;extensions&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="s1">&#39;extensions&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">required_extensions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">created_extensions</span><span class="p">:</span>
                <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
                    <span class="s1">&#39;CREATE EXTENSION IF NOT EXISTS &quot;</span><span class="si">{}</span><span class="s1">&quot; &#39;</span>
                    <span class="s1">&#39;SCHEMA &quot;extensions&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;COMMIT&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">created_extensions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span></div>

<div class="viewcode-block" id="SessionManager.ensure_schema_exists"><a class="viewcode-back" href="../../../../onegov_core.html#onegov.core.orm.SessionManager.ensure_schema_exists">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_schema_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Makes sure the schema exists on the database. If it doesn&#39;t, it</span>
<span class="sd">        is created.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">schema</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">created_schemas</span><span class="p">:</span>

            <span class="c1"># XXX circular dependencies</span>
            <span class="kn">from</span> <span class="nn">onegov.core</span> <span class="k">import</span> <span class="n">upgrade</span>

            <span class="c1"># this is important because CREATE SCHEMA is done in a possibly</span>
            <span class="c1"># dangerous way!</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

            <span class="c1"># setup the extensions right before we activate our first schema</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_required_extensions</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_schema_if_not_exists</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">)</span>
            <span class="n">declared_classes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">:</span>
                    <span class="n">base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span>
                    <span class="n">base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

                    <span class="n">declared_classes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">_decl_class_registry</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;COMMIT&#39;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># reset the schema on the global base variable - this state</span>
                <span class="c1"># sticks around otherwise and haunts us in the tests</span>
                <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">:</span>
                    <span class="n">base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># if we have an upgrade state table, we want to prefill it with</span>
            <span class="c1"># all the current modules/tasks, to get the correct initial update</span>
            <span class="c1"># state (see https://github.com/OneGov/onegov.core/issues/8)</span>
            <span class="c1">#</span>
            <span class="c1"># we usually want to do that, but during testing, those upgrade</span>
            <span class="c1"># state classes may not exist, that&#39;s why we check</span>
            <span class="k">if</span> <span class="n">upgrade</span><span class="o">.</span><span class="n">UpgradeState</span> <span class="ow">in</span> <span class="n">declared_classes</span><span class="p">:</span>

                <span class="c1"># we use a special session that is not registered with the</span>
                <span class="c1"># zope transaction extension -&gt; we do this during a request</span>
                <span class="c1"># and we don&#39;t want the whole request to be commited, just</span>
                <span class="c1"># this small change.</span>
                <span class="n">session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">)()</span>
                <span class="n">upgrade</span><span class="o">.</span><span class="n">register_all_modules_and_tasks</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
                <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">created_schemas</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../index.html">
    <img class="logo" src="../../../../_static/logo.svg" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=OneGov&repo=onegov-docs&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Verein OneGov.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>